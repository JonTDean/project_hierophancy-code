# Ports & Types (Appendix)

```python
from typing import Protocol, Optional, Iterable
from numpy.typing import NDArray
from src.lib.domain.models.graph import Graph
from src.lib.domain.types.nodes import NodeLike

class EmbeddingPort(Protocol):
    def fit_transform(self, G: Graph) -> tuple[NDArray, dict[NodeLike, int]]: ...
    def inverse_transform(self, Y: NDArray) -> Optional[NDArray]: ...

class GeodesicPort(Protocol):
    def pairwise(self, G: Graph) -> NDArray: ...  # returns dense or CSR distance matrix

class LaplacianPort(Protocol):
    def laplacians(self, G: Graph, *, normalized: bool = True) -> tuple[NDArray, NDArray, NDArray]: ...

class ChartPort(Protocol):
    def fit(self, X: NDArray, *, k: int = 15) -> dict[int, dict[str, NDArray]]: ...

class CurvaturePort(Protocol):
    def node_edge_curvature(self, G: Graph) -> tuple[dict[NodeLike, float], dict[tuple[NodeLike, NodeLike], float]]: ...

class FlatteningFlowPort(Protocol):
    def init(self, X: NDArray) -> None: ...
    def step(self) -> None: ...
    def encode(self, X: NDArray) -> NDArray: ...
    def decode(self, Z: NDArray) -> NDArray: ...

class ManifoldMetricsPort(Protocol):
    def trustworthiness(self, X: NDArray, Y: NDArray, *, k: int = 15) -> float: ...
    def continuity(self, X: NDArray, Y: NDArray, *, k: int = 15) -> float: ...
    def geodesic_distortion(self, D_geo, Y: NDArray) -> float: ...
```
